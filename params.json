{"name":"Infraestructura como servicio","tagline":"IaaS y cómo usarlos; configuración, orquestación y todo eso. ","body":"#Infraestructura como servicio\r\n\r\n\r\n##Objetivos\r\n\r\n1. Diseñar, construir y analizar las prestaciones de un centro de\r\n  proceso de datos virtual. \r\n  2. Documentar y mantener una plataforma virtual.\r\n3. Realizar tareas de administración en infraestructura virtual.\r\n4. Aprender lenguajes de configuración usados en infraestructuras virtuales.\r\n2. Saber cómo aplicarlos en un caso determinado.\r\n3. Conocer los sistemas de gestión de la configuración,\r\nprovisionamiento y monitorizació más usados hoy en día.\r\n\r\n</div>\r\n\r\nIntroducción\r\n---\r\n\r\nLas infraestructuras virtuales se gestionan a través de una serie de herramientas denominadas, en general,\r\n[gestores de configuración](http://en.wikipedia.org/wiki/Configuration_management). [Vagrant](http://en.wikipedia.org/wiki/Vagrant_%28software%29)\r\nes uno de ellos, pero también hay otros: [Chef](http://www.getchef.com/chef/), Salt y Puppet, por\r\nejemplo. Todos son libres, pero\r\n[tienen características específicas](http://en.wikipedia.org/wiki/Comparison_of_open_source_configuration_management_software)\r\nque hay que tener en cuenta a la hora de elegir uno u otro. En el caso\r\nespecífico de\r\n[sistemas operativos](http://en.wikipedia.org/wiki/Configuration_management#Operating_System_configuration_management)\r\nse trata de gestionar automáticamente todas las tareas de\r\nconfiguración de un sistema, automatizando la edición de ficheros de\r\nconfiguración, instalación de software y configuración del mismo,\r\ncreación de usuarios y autenticación, de forma que se pueda hacer de\r\nforma automática y masiva. \r\n\r\nA continuación veremos diferentes ejemplos de sistemas de\r\nconfiguración, empezando por Chef. En\r\n[temas anteriores](Contenedores.md) hemos visto `Juju`, un ejemplo de\r\nsistema de configuración también, aunque específico de Ubuntu. \r\n\r\nUsando Chef para provisionamiento\r\n-----\r\n\r\n [Chef](http://www.getchef.com/chef/) es una herramienta que, en\r\n general, se usa en un servidor que se encarga no sólo de gestionar la\r\n configuración, sino también las versiones. Empezar a usarlo\r\n [es complicado](http://wiki.opscode.com/display/chef/Documentation).\r\n Sin embargo, como\r\n introducción a la gestión de configuraciones se puede usar\r\n [`chef-solo`](http://docs.opscode.com/chef_solo.html), una versión\r\n aislada que permite trabajar en una máquina desde la misma y que, por\r\n tanto, se puede usar como introducción y para probar\r\n configuraciones. \r\n \r\n <div class='nota' markdown='1'>\r\n \r\n Hay varios tutoriales que te permiten, con relativa rapidez, comenzar\r\n a trabajar con Chef-solo en un servidor;\r\n [este te proporciona una serie de ficheros que puedes usar](http://www.opinionatedprogrammer.com/2011/06/chef-solo-tutorial-managing-a-single-server-with-chef/)\r\n y\r\n [este otro es más directo, dando una serie de órdenes](http://www.mechanicalrobotfish.com/blog/2013/01/01/configure-a-server-with-chef-solo-in-five-minutes/). En\r\n todo caso, se trata básicamente tener acceso a un servidor o máquina\r\n virtual, instalar una serie de aplicaciones en él y ejecutarlas sobre\r\n un fichero de configuración\r\n \r\n </div>\r\n \r\n \r\nEn una máquina tipo ubuntu, hay que comenzar instalando Ruby y Ruby\r\nGems, el gestor de librerías  \r\n\r\n\tsudo apt-get install ruby1.9.1 ruby1.9.1-dev rubygems\r\n\t\r\n`chef` se distribuye como una gema, por lo que se puede instalar\r\nsiempre como\r\n\r\n\tsudo gem install ohai chef\r\n\t\r\n[ohai](http://docs.opscode.com/ohai.html) acompaña a `chef` y es usado\r\ndesde el mismo para comprobar características del nodo antes de\r\nejecutar cualquier receta.\r\n\r\nUna [forma más rápida de instalar Chef](http://gettingstartedwithchef.com/first-steps-with-chef.html) es descargarlo directamente desde la página web:\r\n\r\n\tcurl -L https://www.opscode.com/chef/install.sh | bash\r\n\r\nLa última tendrá que ser `sudo bash` en caso de que se quiera instalar como administrador (que será lo normal).\r\n\r\n<div class='ejercicios' markdown='1'>\r\n\r\nInstalar chef en la máquina virtual que vayamos a usar\r\n\r\n</div>\r\n\r\nUna *receta* de Chef\r\n[consiste en crear una serie de ficheros](http://www.mechanicalrobotfish.com/blog/2013/01/01/configure-a-server-with-chef-solo-in-five-minutes/):\r\nuna *lista de ejecución* que especifica qué es lo que se va a\r\nconfigurar; esta lista se incluye en un fichero `node.json`, \r\no *recetario* (*cookbook*) que incluye una serie de *recetas* que\r\nconfiguran, efectivamente, los recursos y, finalmente, un fichero de\r\nconfiguración que dice dónde están los dos ficheros anteriores y\r\ncualquier otro recursos que haga falta. Estos últimos dos ficheros\r\nestán escritos en Ruby. \r\n\r\nVamos a empezar a escribir una recetilla del Chef. Generalmente,\r\n[escribir una receta es algo más complicado](http://reiddraper.com/first-chef-recipe/),\r\npero comenzaremos por una receta muy simple que instale el\r\nimprescindible `emacs` y le asigne un nombre al nodo. Creamos el\r\ndirectorio `chef` en algún sitio conveniente y dentro de ese\r\ndirectorio irán diferentes ficheros.\r\n\r\nEl fichero que contendrá efectivamente la receta se\r\nllamará [`default.rb`](../../ejemplos/chef/default.rb)\r\n\r\n\tpackage 'emacs'\r\n\tdirectory '/home/jmerelo/Documentos'\r\n\tfile \"/home/jmerelo/Documentos/LEEME\" do\r\n\t\towner \"jmerelo\"\r\n\t\tgroup \"jmerelo\"\r\n\t\tmode 00544\r\n\t\taction :create\r\n\t\tcontent \"Directorio para documentos diversos\"\r\n\tend\r\n\r\nEl nombre del fichero indica que se trata de la receta por omisión,\r\npero el nombre de la receta viene determinado por el directorio en el\r\nque se meta, que podemos crear de un tirón con\r\n\r\n\tmkdir -p chef/cookbooks/emacs/recipes\r\n\r\nEste fichero tiene tres partes: instala el paquete `emacs`, crea un\r\ndirectorio para documentos y dentro de él un fichero que explica, por\r\nsi hubiera duda, de qué se trata. Evidentemente, tanto caminos como\r\nnombres de usuario se deben cambiar a los correspondientes en la\r\nmáquina virtual que estemos configurando.\r\n\r\nEl siguiente fichero, [`node.json`](../../ejemplos/chef/node.json),\r\nincluirá una referencia a esta receta\r\n\r\n\t{\r\n\t\t\"run_list\": [ \"recipe[emacs]\" ]\r\n\t}\r\n\r\nEste fichero hace referencia a un recetario, `emacs` y dado que no se\r\nespecifica nada más se ejecutará la receta por defecto. \r\n\r\nFinalmente, el [fichero de configuración `solo.rb`](../../ejemplos/solo.rb) incluirá referencias a ambos.\r\n\r\n\tfile_cache_path \"/home/jmerelo/chef\"\r\n\tcookbook_path \"/home/jmerelo/chef/cookbooks\"\r\n\tjson_attribs \"/home/jmerelo/chef/node.json\"\r\n\t\r\nUna vez más, *cambiando los caminos por los que correspondan*. Para\r\nejecutarlo,\r\n\r\n\tsudo chef-solo -c chef/solo.rb\r\n\r\n(si se ejecuta desde el directorio raíz). Esta orden producirá una\r\nserie de mensajes para cada una de las órdenes y, si todo va bien,\r\ntendremos este útil editor instalado.\r\n\r\n<div class='ejercicios' markdown='1'>\r\n\r\nCrear una receta para instalar `nginx`, tu editor favorito y algún\r\ndirectorio y fichero que uses de forma habitual. \r\n\r\n</div>\r\n\r\nPara usar `chef-solo` hay simplemente que instalar unos cuantos\r\nprogramas, pero en gran parte ya está automatizado:\r\n[aquí explica como usarlo en Ubuntu 12.04](http://www.wolfe.id.au/2012/09/10/how-i-use-chef-solo-with-ubuntu-12.04/),\r\npor ejemplo basándose en\r\n[este Gist (programas cortos en GitHug)](https://gist.github.com/wolfeidau/3328844)\r\nque instala todas las herramientas necesarias para comenzar a ejecutar\r\nchef. \r\n\r\n<div class='nota' markdown='1'>\r\n\r\nEste\r\n[curso en video](http://nathenharvey.com/blog/2012/12/06/learning-chef-part-1/)\r\nte enseña también a trabajar con Chef\r\n\r\n</div>\r\n\r\n<div class='nota' markdown='1'>\r\n\r\nDe ninguna manera JSON es un lenguaje universal para gestión de\r\nconfiguraciones. Prácticamente todo el resto de los sistemas de\r\nconfiguración usan\r\n[YAML (*yet another markup language*)](http://yaml.org). Recientemente\r\nse ha\r\n[publicado una introducción al tema](http://pharalax.com/blog/yaml-introduccion-al-lenguaje-yaml/)\r\nque será suficiente para el uso que le vamos a dar más adelante\r\n\r\n</div>\r\n\r\n<div class='ejercicios' markdown='1'>\r\n\r\nEscribir en YAML la siguiente estructura de datos en JSON\r\n\r\n\t{ uno: \"dos\",\r\n      tres: [ 4, 5, \"Seis\", { siete: 8, nueve: [ 10, 11 ] } ] }\r\n\t  \r\n</div>\r\n\r\nNormalmente estas recetas van a estar bajo control de un sistema de\r\ngestión de fuentes; de esta forma se pueden probar diferentes\r\nconfiguraciones, crear nuevas versiones de la misma pero, sobre todo,\r\ntener claro en cada momento qué configuración es la que se está\r\nejecutando en producción, que será habitualmente la que esté en una\r\nrama designada de la misma. \r\n\r\nOtros sistemas de gestión de configuración\r\n---\r\n\r\nLas principales alternativas a Chef son [Ansible](http://ansible.com),\r\n[Salt](http://www.saltstack.com/) y [Puppet](http://docs.puppetlabs.com/guides/installation.html). Todos ellos se comparan en\r\n[este artículo](http://www.infoworld.com/d/data-center/review-puppet-vs-chef-vs-ansible-vs-salt-231308),\r\naunque los principales contendientes son\r\n[Puppet y Chef, sin que ninguno de los dos sea perfecto](http://www.infoworld.com/d/data-center/puppet-or-chef-the-configuration-management-dilemma-215279?source=fssr). \r\n\r\nDe todas ellas, vamos a\r\n[ver Ansible](http://davidwinter.me/articles/2013/11/23/introduction-to-ansible/)\r\nque parece ser uno de los que se está desarrollando con más intensidad\r\núltimamente. [Ansible es](http://en.wikipedia.org/wiki/Ansible_%28software%29)\r\nsistema de gestión remota de configuración que permite gestionar\r\nsimultáneamente miles de sistemas diferenets. Está basado en YAML para\r\nla descripción de los sistemas y escrito en Python. \r\n\r\nSe instala como un módulo de Python, usando por ejemplo la utilidad de\r\ninstalación de módulos `pip` (que habrá que instalar si no se tiene)\r\n\r\n\tsudo pip install paramiko PyYAML jinja2 httplib2 ansible\r\n\t\r\nEl resto de las utilidades son también necesarias y en realidad se\r\ninstalan automáticamente al instalar ansible. Estas utilidades se\r\ntienen que instalar *en el anfitrión*, no hace falta instalarlas en el\r\ninvitado, que lo único que necesitará, en principio, es tener activada\r\nla conexión por ssh y tener una cuenta válida y forma válida de\r\nacceder a ella.\r\n\r\nCada máquina que se añada al control de Ansible se tiene que añadir a\r\nun\r\n[fichero, llamado inventario](http://docs.ansible.com/intro_inventory.html),\r\nque contiene las diferentes máquinas controladas por el mismo. Por\r\nejemplo\r\n\r\n\t $ echo \"ansible-iv.cloudapp.net\" > ~/ansible_hosts\r\n\t\r\nse puede ejecutar desde el *shell* para meter (`echo`) una cadena con\r\nuna dirección (en este caso, una máquina virtual de Azure) en el\r\nfichero `ansible_hosts` situado en mi directorio raíz. El lugar de ese\r\nfichero es arbitrario, por lo que habrá que avisar a Ansible donde\r\nestá usando una variable de entorno:\r\n\r\n\texport ANSIBLE_HOSTS=~/ansible_hosts\r\n\t\r\nY, con un nodo, ya se puede comprobar si Ansible funciona con \r\n\r\n\t$ ansible all -u jjmerelo -m ping\r\n\t\r\nEsta orden hace un *ping*, es decir, simplemente comprueba si la\r\nmáquina es accesible desde la máquina local. `-u ` incluye el nombre\r\ndel usuario (si es diferente del de la máquina local); habrá que\r\nañadir `--ask-pass` si no se ha configurado la máquina remota para\r\npoder acceder a ella sin clave. \r\n\r\nDe forma básica, lo que hace Ansible es simplemente ejecutar comandos\r\nde forma remota y simultáneamente. Para hacerlo, podemos usar el\r\n[inventario para agrupar los servidores](http://docs.ansible.com/intro_inventory.html), por ejemplo\r\n\r\n\t[azure]\r\n\tiv-ansible.cloudapp.net\r\n\r\ncrearía un grupo `azure` (con un solo ordenador), en el cual podemos\r\nejecutar comandos de forma remota\r\n\r\n\t$ ansible azure -u jjmerelo -a df\r\n\t\r\nnos mostraría en todas las máqunias de azure la organización del\r\nsistema de ficheros (que es lo que hace el comando `df`). Una vez más,\r\n`-u` es opcional. \r\n\r\nEsta orden usa un *módulo* de ansible y se puede ejecutar también de\r\nesta forma:\r\n\r\n\t$ ansible azure -m shell ls\r\n\t\r\nhaciendo uso del módulo `shell`. Hay muchos\r\n[más módulos](http://docs.ansible.com/modules.html) a los que se le\r\npueden enviar comandos del tipo \"variable = valor\". Por ejemplo, se\r\npuede trabajar con servidores web o\r\n[copiar ficheros](http://docs.ansible.com/intro_adhoc.html#file-transfer)\r\no\r\n[incluso desplegar aplicaciones directamente usando el módulo `git`](http://docs.ansible.com/intro_adhoc.html#managing-packages)\r\n\r\n<div class='ejercicios' markdown='1'>\r\n\r\nDesplegar los fuentes de la aplicación de  DAI o cualquier otra aplicación que se\r\nencuentre en un servidor git público en la máquina virtual Azure (o\r\nuna máquina virtual local) usando ansible.\r\n\r\n</div>\r\n\r\nFinalmente, el concepto similar a las recetas de Chef en Ansible son los\r\n[*playbooks*](http://davidwinter.me/articles/2013/11/23/introduction-to-ansible/),\r\nficheros en YAML que le dicen a la máquina virtual qué es lo que hay\r\nque instalar en *tareas*, de la forma siguiente\r\n\r\n\t---\r\n\t- hosts: azure\r\n\t  sudo: yes\r\n\t  tasks:\r\n\t\t- name: Update emacs\r\n\t\t  apt: pkg=emacs state=present\r\n\r\nEsto se guarda en un fichero y se\r\n[le llama, por ejemplo, emacs.yml](../../ejemplos/ansible/emacs.yml),\r\ny se ejecuta con \r\n\r\n  ansible-playbook ../../ejemplos/ansible/emacs.yml \r\n  \r\n(recordando siempre el temita del nombre de usuario), lo que dará, si\r\ntodo ha ido bien, un resultado como el siguiente\r\n\r\n![Instalación de emacs usando ansible](img/ansible.png)\r\n\r\nEn el fichero YAML lo que se está expresando es un array asociativo\r\ncon las claves `hosts`, `sudo` y `tasks`. En el primero ponemos el\r\nbloque de servidores en el que vamos a actuar, en el segundo si hace\r\nfalta hacer sudo o no y en el tercero las tareas que vamos a ejecutar,\r\nen este caso una sola. El apartado de tareas es un vector de hashes,\r\ncada uno de los cuales tiene en `name` el nombre de la tarea, a título\r\ninformativo y en las otras claves lo que se va a hacer; `apt` indicará\r\nque hay que instalar un paquete (`pkg`) llamado `emacs` y que hay que\r\ncomprobar si está presente o no (`state`). El que se trabaje con\r\n*estados* y no de forma imperativa hace que los *playbooks* sean\r\n*idempotentes*, es decir, si se ejecutan varias veces darán el mismo\r\nresultado que si se ejecutan una sola vez. \r\n\r\n<div class='ejercicios' markdown='1'>\r\n\r\n1. Desplegar la aplicación de DAI  con todos los módulos necesarios\r\nusando un *playbook* de Ansible.\r\n\r\n2. [¿Ansible o Chef? ¿O cualquier otro que no hemos usado aquí?](https://github.com/IV-GII/GII-2013/issues/131). \r\n\r\n</div>\r\n\r\nOrquestación de máquinas virtuales\r\n---------------\r\n\r\nA un nivel superior al provisionamiento de máquinas virtuales está la configuración,\r\norquestación y gestión de las mismas, herramientas como\r\n[Vagrant](http://vagrantup.com) ayudan a hacerlo, aunque también\r\nPuppet e incluso Juju pueden hacer muchas de las funciones de\r\nVagrant. Algunas alternativas son\r\n[Vortex](http://www.websecurify.com/extra/vortex.html) \r\n\r\nLa ventaja de Vagrant es que permite gestionar el ciclo de vida\r\ncompleto de una máquina virtual, desde la creación hasta su\r\ndestrucción pasando por el provisionamiento y la monitorización o\r\nconexión con la misma. Además, permite trabajar con todo tipo de\r\nhipervisores y provisionadores tales como los que hemos visto\r\nanteriormente.\r\n\r\nCon Vagrant [te puedes descargar directamente](https://gist.github.com/dergachev/3866825)\r\n[una máquina configurada de esta lista](http://www.vagrantbox.es/). Por\r\nejemplo, \r\n\r\n\tvagrant box add centos65 https://github.com/2creatives/vagrant-centos/releases/download/v6.5.1/centos65-x86_64-20131205.box\r\n\r\nEl formato determinará en qué tipo de hipervisor se puede ejecutar; en\r\ngeneral, Vagrant usa VirtualBox, y los `.box` se ejecutan precisamente\r\nen ese formato. Otras imágenes están configuradas para trabajar con\r\nVMWare, pero son las menos. A continuación,\r\n\r\n\tvagrant init centos65\r\n\t\r\ncrea un fichero `Vagrantfile` (y así te lo dice) que permite trabajar\r\ny llevar a cabo cualquier configuración adicional. Una vez hecho eso\r\nya podemos inicializar la máquina y trabajar con ella (pero antes voy\r\na apagar la máquina Azure que tengo ejecutándose desde que empecé a\r\ncontar lo anterior)\r\n\r\n\tvagrant up\r\n\t\r\ny se puede empezar a trabajar en ella con \r\n\r\n\tvagrant ssh\r\n\t\r\n<div class='ejercicios' markdown='1'>\r\n\r\n\tInstalar una máquina virtual Debian usando Vagrant y conectar con ella.\r\n\t\r\n</div>\r\n\r\n\t\r\nUna vez creada la máquina virtual se puede entrar en ella y\r\nconfigurarla e instalar todo lo necesario. Pero, por supuesto,\r\nsabiendo lo que sabemos sobre provisionamiento, Vagrant permite\r\n[provisionarla de muchas maneras diferentes](http://docs.vagrantup.com/v2/provisioning/index.html). En\r\ngeneral, Vagrant usará opciones de configuración diferente dependiendo\r\ndel provisionador, subirá un fichero a un directorio temporal del\r\nmismo y lo ejecutará (tras ejecutar todo lo necesario para el mismo). \r\n\r\nLa provisión tiene lugar cuando se *alza* una máquina virtual (con\r\n`vagrant up`) o bien explícitamente haciendo `vagrant provision`. En\r\ncualquier caso se lee del Vagrantfile y se llevan a cabo las acciones\r\nespecificadas en el fichero de configuración. \r\n\r\nEn general, trabajar con un provisionador requiere especificar de cuál\r\nse trata y luego dar una serie de órdenes específicas. Comenzaremos\r\npor el\r\n[*shell*](http://docs.vagrantup.com/v2/provisioning/shell.html), que\r\nes el más simple y, en realidad, equivale a entrar en la máquina y dar\r\nlas órdenes a mano. Instalaremos, como hemos hecho en otras ocasiones,\r\nel utilísimo editor `emacs`usando este\r\n[`Vagrantfile`](../../ejemplos/vagrant/provision/Vagrantfile):\r\n\r\n\tVAGRANTFILE_API_VERSION = \"2\"\r\n\r\n\tVagrant.configure(VAGRANTFILE_API_VERSION) do |config|\r\n\t\tconfig.vm.box = \"centos65\"\r\n\r\n\t    config.vm.provision \"shell\",\r\n\t\t\tinline: \"yum install -y emacs\"\r\n\tend\r\n\r\nRecordemos que se trata de un programa en Ruby en el cual configuramos\r\nla máquina virtual. La 4ª línea indica el nombre de la máquina con la\r\nque vamos a trabajar (que puede ser la usada en el caso anterior);\r\nrecordemos también que, por omisión, se trabaja con VirtualBox (si se\r\nhiciera con algún otro tipo de hipervisor habría que usar el *plugin*\r\ncorrespondiente e inicializar la máquina de alguna otra forma). La\r\nparte en la que efectivamente se hace la provisión va justamente a\r\ncontinuación. La orden `config.vm.provision` indica que se va a usar\r\nel sistema de provisión del `shell`, es decir, órdenes de la línea de\r\ncomandos; se le pasa un hash en Ruby  (variable: valor, tal como en\r\njavascript, separados por comas) en el que la clave `inline` indica el\r\ncomando que se va a ejecutar, en este caso `yum`, el programa para\r\ninstalar paquetes en CentOS, y al que se le indica `-y` para que\r\nconteste *Yes* a todas las preguntas sobre la instalación. \r\n\r\nEste Vagrantfile no necesita nada especial para ejecutarse: se le\r\nllama directamente cuando se ejecuta `vagrant up` o explícitamente\r\ncuando se llama con `vagrant provision`. Lo único que hará es instalar\r\neste programa bajándose todas sus dependencias (y tardará un rato).\r\n\r\n<div class='ejercicios' markdown='1'>\r\n\r\n\tCrear un script para provisionar `nginx` o cualquier otro servidor\r\n\tweb que pueda ser útil para alguna otra práctica\r\n\t\r\n</div>\r\n\r\n<div class='nota' markdown='1'>\r\n\r\nEl provisionamiento por *shell* admite\r\n[muchas más opciones](http://docs.vagrantup.com/v2/provisioning/shell.html):\r\nse puede usar un fichero externo o incluso alojado en un sitio web\r\n(por ejemplo, un Gist alojado en Github). Por ejemplo,\r\n[este para provisionar nginx y node](https://gist.github.com/DamonOehlman/5754302)\r\n(no leer hasta después de hacer el ejercicio anterior).\r\n\r\n</div>\r\n\r\nEl poblema con los guiones de *shell* (y no sé por qué diablos pongo\r\nguiones si pongo shell, podía poner scripts de shell directametne y\r\ntodo el mundo me entendería, o guiones de la concha y nadie me\r\nentendería) es que son específicos de una máquina. Por eso Vagrant\r\npermite muchas otras formas de configuración, incluyendo casi todos\r\nlos sistemas de provisionamiento populares (Chef, Puppet, Ansible,\r\nSalt) y otros sistemas com Docker, que también hemos visto. La ventaja\r\nde estos sistemas de más alto nivel es que permiten trabajar\r\nindependientemente del sistema operativo. Cada uno de ellos tendrá sus\r\nopciones específicas, pero veamos cómo se haría lo anterior usando el\r\nprovisionador\r\n[chef-solo](http://docs.vagrantup.com/v2/provisioning/chef_solo.html).\r\n\r\nPara empezar, hay que provisionar la máquina virtual para que funcione\r\ncon chef-solo y hay que hacerlo desde shell o Ansible;\r\n[este ejemplo](../../ejemplos/vagrant/provision/chef-with-shell/Vagrantfile)\r\nque usa\r\n[este fichero shell](../../ejemplos/vagrant/provision/chef-with-shell/chef-solo.sh)\r\npuede provisionar, por ejemplo, una máquina CentOS. \r\n\r\nUna vez preinstalado chef (lo que también podíamos haber hecho con\r\n[una máquina que ya lo tuviera instalado, de las que hay muchas en `vagrantbox.es`](http://www.vagrantbox.es/)git co\r\ny de hecho es la mejor opción porque chef-solo no se puede instalar en\r\nla versión 6.5 de Centos fácilmente por no tener una versión\r\nactualizada de Ruby)\r\nincluimos en el Vagrantfile. las órdenes para usarlo en\r\n[este Vagrantfile](../../ejemplos/vagrant/provision/chef/Vagrantfile) \r\n\r\n\tVAGRANTFILE_API_VERSION = \"2\"\r\n\r\n\tVagrant.configure(VAGRANTFILE_API_VERSION) do |config|\r\n\t\tconfig.vm.box = \"centos63\"\r\n\r\n\t    config.vm.provision \"chef_solo\" do |chef|\r\n\t\t\tchef.add_recipe \"emacs\"\r\n\t\tend\r\n\r\n\tend\r\n\r\nEste fichero usa un bloque de Ruby para pasarle variables y\r\nsimplemente declara que se va a usar la receta `emacs`, que\r\npreviamente tendremos que haber creado en un subdirectorio cookbooks\r\nque descienda exactamente del mismo directorio y que contenga\r\nsimplemente `package 'emacs'` que tendrá que estar en un fichero \r\n\r\n\tcookbooks/emacs/recipes/default.rb\r\n\t\r\nCon todo esto se puede configurar emacs. Pero, la verdad, seguro que\r\nes más fácil hacerlo en Ansible y/o en otro sistema operativo que no\r\nsea CentOS porque yo, por lo pronto, no he logrado instalar chef-solo\r\nen ninguna de las máquinas pre-configuradas de VagrantBoxes. \r\n\r\n<div class='ejercicios' markdown='1'>\r\n\r\n\tConfigurar tu máquina virtual usando vagrant con el provisionador\r\n\tansible\r\n\t\r\n</div>\r\n\r\nDesde Vagrant se puede crear también una\r\n[caja base](http://docs.vagrantup.com/v2/boxes/base.html) con lo\r\nmínimo necesario para poder funcionar, incluyendo el soporte para ssh\r\ny provisionadores como Chef o Puppet. Se puede crear directamente en\r\nVirtualBox y usar\r\n[`vagrant package`](http://docs.vagrantup.com/v2/cli/package.html)\r\npara *empaquetarla* y usarla para su consumo posterior. \r\n\r\nA donde ir desde aquí\r\n-------\r\n\r\nEste es el último tema del curso, pero a partir de aquí se puede\r\nseguir aprendiendo sobre devops en [el blog](http://devops.com/) o\r\n[en IBM](http://www.ibm.com/ibm/devops/us/en/). Libros como\r\n[DevOps for Developers](https://www.amazon.es/dp/B009D6ZB0G?tag=atalaya-21&camp=3634&creative=24822&linkCode=as4&creativeASIN=B009D6ZB0G&adid=0PB61Y2QD9K49W3EP8MN&)\r\npueden ser también de ayuda.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}